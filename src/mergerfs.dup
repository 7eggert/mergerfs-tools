#!/usr/bin/env python3

# Copyright (c) 2016, Antonio SJ Musumeci <trapexit@spawn.link>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import argparse
import ctypes
import collections
import errno
import fnmatch
import os
import subprocess
import sys


_libc = ctypes.CDLL("libc.so.6",use_errno=True)
_lgetxattr = _libc.lgetxattr
_lgetxattr.argtypes = [ctypes.c_char_p,ctypes.c_char_p,ctypes.c_void_p,ctypes.c_size_t]
def lgetxattr(path,name):
    if type(path) == str:
        path = path.encode('utf-8','surrogateescape')
    if type(name) == str:
        name = name.encode('utf-8','surrogateescape')
    length = 64
    while True:
        buf = ctypes.create_string_buffer(length)
        res = _lgetxattr(path,name,buf,ctypes.c_size_t(length))
        if res >= 0:
            return buf.raw[0:res]
        else:
            err = ctypes.get_errno()
            if err == errno.ERANGE:
                length *= 2
            elif err == errno.ENODATA:
                return None
            else:
                raise IOError(err,os.strerror(err),path)


def ismergerfs(path):
    try:
        lgetxattr(path,'user.mergerfs.allpaths')
        return True
    except IOError as e:
        return False


def mergerfs_control_file(basedir):
    if basedir == '/':
        return None
    ctrlfile = os.path.join(basedir,'.mergerfs')
    if os.path.exists(ctrlfile):
        return ctrlfile
    basedir = os.path.dirname(basedir)
    return mergerfs_control_file(basedir)


def mergerfs_branches(ctrlfile):
    branches = lgetxattr(ctrlfile,b'user.mergerfs.srcmounts')
    branches = branches.split(b':')
    return branches


def match(filename,matches):
    for match in matches:
        if fnmatch.fnmatch(filename,match):
            return True
    return False


def execute(args):
    return subprocess.call(args)


def build_copy_file_rel(src,tgt,relfile):
    frompath = os.path.join(src+b'/',b'./',relfile)
    topath   = tgt+b'/'
    return [b'rsync',
            b'-alHAWXSv',
            b'--relative',
            b'--progress',
            frompath,
            topath]


def build_copy_file(src,tgt):
    return [b'rsync',
            b'-alHAWXSv',
            b'--progress',
            src,
            tgt]


def build_branches_freespace(branches):
    rv = dict()
    for branch in branches:
        st = os.statvfs(branch)
        rv[branch] = st.f_bavail * st.f_frsize
    return rv


def buildargparser():
    desc = 'Duplicate files & directories across multiple drives in pool'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('dir',
                        type=str,
                        help='starting directory')
    parser.add_argument('-c','--count',
                        dest='count',
                        type=int,
                        default=2,
                        help='number of versions')
    parser.add_argument('-i','--include',
                        dest='include',
                        type=str,
                        action='append',
                        default=[],
                        help='fnmatch compatible file filter (can use multiple times)')
    parser.add_argument('-e','--exclude',
                        dest='exclude',
                        type=str,
                        action='append',
                        default=[],
                        help='fnmatch compatible file filter (can use multiple times)')
    return parser


def mergerfs_allpaths(fullpath):
    rv = lgetxattr(fullpath,b'user.mergerfs.allpaths')
    return rv.split(b'\0')


def mergerfs_basepath(fullpath):
    return lgetxattr(fullpath,b'user.mergerfs.basepath')


def mergerfs_relpath(fullpath):
    return lgetxattr(fullpath,b'user.mergerfs.relpath')


def main():
    parser = buildargparser()
    args = parser.parse_args()

    args.dir = os.path.realpath(args.dir)

    if not ismergerfs(args.dir):
        print("%s is not a mergerfs mount" % args.dir)
        sys.exit(1)

    count     = args.count
    execute   = args.execute
    includes  = ['*'] if not args.include else args.include
    excludes  = args.exclude
    ctrlfile  = mergerfs_control_file(args.dir)
    branches  = mergerfs_branches(ctrlfile)
    branches  = build_branches_freespace(branches)

    try:
        for (dirpath,dirnames,filenames) in os.walk(args.dir):
            for filename in filenames:
                if match(filename,excludes):
                    continue
                if not match(filename,includes):
                    continue

                fullpath = os.path.join(dirpath,filename)
                relpath  = mergerfs_relpath(fullpath)
                existing = mergerfs_allpaths(fullpath)
                src_file = find_source_file(existing)
                src_file_size = os.stat(source_file).st_size
                existing.remove(src_file)

                i = 1
                for tgt_file in existing:
                    args = build_copy_file(src_file,tgt_file)
                    print(args)
                    if execute:
                        pass
                    i += 1

                for c in range(i,count):
                    for (branch,freespace) in sorted(branches,key=branches.get):
                        tgt_file = os.path.join(branch,relpath)
                        if os.path.exists(tgt_file):
                            continue
                        args = build_copy_file(src_file,tgt_file)
                        print(args)
                        if execute:
                            pass
                        break

    except KeyboardInterrupt:
        print("exiting: CTRL-C pressed")

    sys.exit(0)


if __name__ == "__main__":
   main()
